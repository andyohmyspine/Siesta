#include "HeaderGenerator.h"
#include <ranges>

SHeaderGenerator::SHeaderGenerator(const DParsedFolderData& FolderData)
	: m_FolderData(FolderData)
{
}

PVector<DHeaderText> SHeaderGenerator::GenerateHeaders() const
{
	PVector<DHeaderText> Output;
	PHashMap<TString, PVector<DParsedTypeInfo>> FileToTypeMap;

	for (const auto& Type : m_FolderData.Types)
	{
		FileToTypeMap[Type.File].push_back(Type);
	}

	for (const TString& FileName : FileToTypeMap | std::views::keys)
	{
		TStringStream HeaderStream;
		HeaderStream << "// This file was generated by Siesta.ReflectionTool. DO NOT MODIFY - IT'S POINTLESS. It will be regenerated on the next build.\n\n";
		HeaderStream << "#pragma once\n";
		
		// Generate file id
		HeaderStream << "#ifdef SIESTA_FILE_ID\n#undef SIESTA_FILE_ID\n#endif\n#define SIESTA_FILE_ID _" << FileName << "_" << '\n';
		
		HeaderStream << "class SType;\n";

		for (const auto& Type : FileToTypeMap.at(FileName))
		{
			// Generate field infos, method infos, and type info
			HeaderStream << FormatString("#define SIESTA_TYPE_{}_ClassInfo using TSelf = {};", Type.Name, Type.Name);
			if (!Type.Parent.empty())
			{
				HeaderStream << FormatString("using TBase = {};", Type.Parent);
			}

			HeaderStream << FormatString("friend class SType_{};", Type.Name);
			HeaderStream << "public:static SType* GetStaticType(); private:\n";
			HeaderStream << "\n";

			TString TypeFulfillment = FormatString("SIESTA_TYPE_{}_ClassInfo", Type.Name);
			HeaderStream << fmt::format("#define SIESTA_FILE_{}_{} {}\n", FileName, Type.GeneratedBodyLine, TypeFulfillment);
		}

		DHeaderText HeaderText
		{
			.HeaderName = FileName,
			.HeaderText = HeaderStream.str()
		};
		Output.push_back(HeaderText);
	}


	return Output;
}

